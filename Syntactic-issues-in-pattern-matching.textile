h2. Syntactic issues in pattern matching

This page captures a bunch of axes in the space of pattern matching syntax.

h3. Allow pattern guards, using @if@ or @when@ or @where@ or @|@.

*Pros*
* very expressive

*Cons*
* requires conservative approximation for exhaustiveness checking

h3. Use @=@ or @==@ for non-pattern expressions whose result is matched by @==@.

*Pros*
* very expressive

*Cons*
* requires conservative approximation for exhaustiveness checking
* could be simulated with just pattern guards

h3. Use @and@ or @as@ for compound patterns.

This is important for destructuring but still being able to bind a name to the destructured thing:

bc. var (x, y) as t = foo();

The right-hand side can in fact be an arbitrary pattern.

h3. Distinguish bindings from assignments by context vs by keyword.

We could allow individual variables in a pattern to be distinguished as assignments vs. bindings by use of a keyword, but always requiring the keyword (such as @var@) is very verbose (see the discussion of distinguishing variables from tags below). The alternative is to have binding positions for patterns and assignment positions for patterns, and not to distinguish them.

A hybrid approach is to distinguish binding positions and assignment positions, but to optionally allow binding variables in an assignment position. For example:

bc. var (a, b) = foo(); // always binding
(a, b) = bar(); // always assignment
(a, var c) = baz(); // defaults to assignment, but the use of 'var' overrides to bind a new variable

h3. How to distinguish variables from tags.

This is the biggest and subtlest issue in this space. Following are a bunch of alternatives we've discussed.

h4. Use @?@ to mark variables, or to mark variable bindings only.

*Cons*
* pattern matching becomes much more noisy and verbose
* binding positions in the language can't be defined as just patterns; it depends on whether they are a single variable (no sigil) or a pattern (sigils)
* maybe looks weird for variables in non-binding position, when used in destructuring assignment

h4. Use @var@ to mark variables, or to mark variable bindings only.

*Pros*
* possible to use arbitrary expressions without an @=@ sigil (this is arguably not a pro)

*Cons*
* Dave *absolutely hates* this option :)
* pattern matching becomes extremely verbose

h4. Use a sigil like @$@ to mark tags, or to mark nullary tags only.

*Cons*
* papercut: nullary patterns are common; if they are a special case that needs disambiguation, programmers will curse us eternally

h4. Use distinct lexical classes for tag names and variables.

This is what ML and Haskell do.

*Pros*
* simple, relatively tasteful

*Cons*
* Rust has so far avoided any special lexical classes
* in the C tradition, CapitalizedNames are typically type, module, or class names
* in the C tradition, ALL_CAPS_NAMES are typically constants

h4. Use @==@ to mark nullary tags.

*Pros*
* since nullary tags don't bind variables, the @=@ case happens to coincide with the right meaning

*Cons*
* again, papercut: special case for common case of nullary tags means death of a thousand papercuts

h4. Use the type of the pattern to disambiguate, and disallow the use of tag names of the current pattern's type as variables.

This is more hostile to tools, and trickier to define and implement, because it imposes a two-way dependency between type checking and variable resolution.

h4. Use the current scope to disambiguate, and disallow the use of tag names as variables.

This is currently Patrick and Dave's favorite.

*Pros*
* better phase separation
* no lexical classes
* no special sigils
* the clashes are probably unlikely to occur in practice
* all binding and lvalue positions can be specified as patterns

*Cons*
* somewhat of a refactoring hazard: introducing a new tag into scope can break a pattern match
