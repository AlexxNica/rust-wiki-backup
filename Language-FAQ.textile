h3. I'm impatient. Can you give a brief summary of the salient features?

h4. Safety oriented:
* Memory safe. No null pointers, wild pointers, etc. Automatic storage management.
* Mutability control. Immutable by default. No shared mutable state across tasks.
* Dynamic execution safety: task failure / unwinding, trapping, logging. RAII / dtors.
* Typestate system: ability to define complex invariants that hold over data structures.

h4. Concurrency and efficiency oriented:
* Explicit memory control. Layout and allocation control. Interior / value types.
* Very lightweight tasks (coroutines). Cheap to spawn thousands-to-millions.
* Stack iterators (effectively lambda-blocks w/o heap allocation).
* Static, native compilation. Emits ELF / PE / Mach-o files.
* Direct and simple interface to C code (switch stacks and call, ~8 insns).

h4. Practicality oriented:
* Multi-paradigm. pure-functional, concurrent-actor, imperative-procedural, OO.
** First class functions with bindings.
** Structurally-typed objects (no nominal types or type hierarchy).
* Multi-platform. Developed on Windows, Linux, OSX.
* UTF-8 strings, assortment of machine-level types.
* Works with existing native toolchains. GDB / Valgrind / Shark / etc.
* Practical rule-breaking: can break safety rules, if explicit about where and how. 

h3. Is it OO? How do I do this thing I normally do in an OO language?

It is multi-paradigm. Not everything is shoe-horned into the object abstraction. Many things you can do in OO languages you can do in Rust, but not everything, and not always using objects.

h3. How do you get away with "no null pointers"?

Data values in the language can only be constructed through a fixed set of initializer forms. Each of those forms requires that its inputs already be initialized. A dataflow analysis (the typestate system used elsewhere) ensures that local variables are initialized before use.

h3. What is the relationship between a module and a crate?

* A crate is a top-level compilation unit that corresponds to a single loadable object.
* A module is a (possibly nested) unit of name-management inside a crate.
* A crate contains an implicit, un-named top-level module.
* Recursive definitions can span modules, but not crates.
* Crates do not have global names, only a set of non-unique metadata tags.
* There is no global inter-crate namespace; all name management occurs within a crate.
** Using another crate binds the root of _its_ namespace into the user's namespace.

h3. Why is failure unwinding non-recoverable within a task? Why not try to "catch exceptions"?

In short, because too few guarantees could be statically made about the dynamic environment of the catch block to be able to safely resume.

In more detail: the origin-state of a failure is unknown by definition, therefore catching it would result in dropping the static typestate of the "catch block" to the lowest initialization typestate in the containing block, as well as dropping all user-defined conditions at any statements in the task. The set of operations that would be legal to perform in such a catch block would be minimal at a local level, and intractable at a task level: there would be no way to tell how much of the typestate assumed by the caller of the catch -- or any other functions in the task -- still holds. This sort of "resume in an arbitrarily damaged state" construct would defeat most of the other static rules in the language.

Rust provides, instead, three predictable and well-defined options for handling any combination of the three main categories of "catch" logic:
* Failure _logging_ is done by the integrated <code>note</code> statement.
* _Recovery_ after a failure is done by by trapping a task failure from _outside_ the task, where the typestate of other tasks is known to be unaffected.
* _Cleanup_ of resources is done by RAII-style objects with destructors.
Cleanup through RAII-style destructors  is more likely to work than in catch blocks anyways, since it will be better tested (part of the non-error control paths, so executed all the time).

h3. Why don't local functions or objects capture their dynamic environment? What's with <code>bind</code>?

Because environment capture would be redundant in two ways, and undermine the goals of clarity and maintainability in two ways:
* Redundancy:
** Because there are a variety of ways in which a slot may refer to a referent (three modes, plus the presence or absence of mutability) we would need to accompany such "automatic capture" with a mechanism similar to the capture clauses present in C++0x lambdas. This strikes us as redundant given that there is already a per-function place to declare slot modes: in the _normal invocation signature_.
** Environment capture only works when you're trying to capture into a locally-defined function. If you want to capture into the arguments of a function defined elsewhere, you _need a <code>bind</code> construct anyways_, if you want to avoid having to write local functions (and capture clauses! see previous point) just to bind an existing argument.
* Clarity and maintainability:
** If the point of being "more implicit" with capture is to support an abbreviated "capture everything mentioned in the function" form of capture clause, such a form would requires the maintenance programmer to read the whole function to know what gets captured. The <code>bind</code> construct is always explicit.
** Because environment-capture would involve taking a snapshot of some slots (but not others: again, depending on the capture clause!) the state that gets captured may, or may not, depend on the statements proceeding and following the local declaration. This deepens the previous maintainability risk: the presence of an easily-overlooked capture clause -- particularly one that abbreviates to capturing "everything" -- attached to a local function declaration would change it from a location-insensitive declaration to one sensitive to the order of statements before and after it.

h3. Why aren't modules type-parametric?

Doing so would require that type-parametric code  is statically expanded, duplicating code. It would also require a complex mechanism inside crates for maintaining uninstantiated module-bodies. While this is a possible implementation approach for parametric code, we don't want to mandate it. We want to maintain the option to parametrize at runtime (this is the default implementation).

h3. Why aren't values type-parametric? Why only items?

Doing so would make type inference much more complex, and require the implementation strategy of runtime parametrization. While this is our default implementation strategy, we don't want to mandate it.

h3. Why are tag types nominal and closed?

We don't know if there's an obvious, easy, efficient, stock-textbook way of supporting open or structural tags. We prefer to stick to language features that have an obvious and well-explored semantics.

h3. Why limit to ASCII outside comments, strings and characters? Why not use the most general Unicode character class for every lexeme?

Our informal conversations with non-English programmers and our search for examples of non-ASCII identifier use in languages that support them has not turned up many leads; it seems non-English programmers still write in ASCII identifiers (and numbers, and whitespace, etc.) Moreover all of our keywords and operators are ASCII-range, so you have to have an ASCII-capable input method to even write Rust code. If you have evidence to suggest we are just not looking in the right places, and non-ASCII identifier use is widespread somewhere we're not aware of, feel free to suggest this change on practical grounds! At the moment it's just a matter of keeping the lexer simple (no character-class tables to consult) as well as any tools that want to work with the language.

h3. Why UTF-8 strings by default? Why not UCS2 or UCS4?

The <code>str</code> type is UTF-8 because we observe more text in the wild in this encoding -- particularly in network transmissions, which are endian-agnostic -- and we think it's best that the default treatment of I/O not involve having to recode codepoints in each direction.

This does mean that indexed access to a Unicode codepoint inside a <code>str</code> value is an O(n) operation. On the one hand, this is clearly undesirable; on the other hand, this problem is full of trade-offs and we'd like to point a few important qualifications:
* Scanning a <code>str</code> for ASCII-range codepoints can still be done safely octet-at-a-time, with each indexing operation pulling out a <code>u8</code> costing only O(1) and producing a value that can be cast and compared to an ASCII-range <code>char</code>. So if you're (say) line-breaking on <code>'\n'</code>, octet-based treatment still works. UTF-8 was well-designed this way.
* Most "character oriented" operations on text only work under very restricted language assumptions sets such as "ASCII-range codepoints only". Outside ASCII-range, you tend to have to use a complex (non-constant-time) algorithm for determining linguistic-unit (glyph, word, paragraph) boundaries anyways. We recommend using an "honest" linguistically-aware, Unicode-approved algorithm.
* The <code>char</code> type is UCS4. If you honestly need to do a lot of codepoint-at-a-time algorithm, it's trivial to write a <code>type wstr = vec[char]</code>, and unpack a <code>str</code> into it in a single pass, then work with the <code>wstr</code>. In other words: the fact that the language is not "decoding to UCS4 by default" shouldn't stop you from decoding (or re-encoding any other way) if you need to work with that encoding.

h3. Does it run on Windows?

Yes. All development happens in lock-step on all 3 target platforms. Using mingw, not cygwin.

h3. Are there any big programs written in it yet? I want to read big samples.

Sorry, no. It doesn't even have much of a standard library yet.

h3. Have you seen this Google language, Go? How does Rust compare?

Yes.
* Rust development was several years underway before Go launched, no direct inspiration.
** Though Pike's previous languages in the Go family (Newsqueak, Alef, Limbo) were influential.
* Go adopted semantics (safety and memory model) that are quite unsatisfactory.
** Shared mutable state.
** Global GC.
** Null pointers.
** No RAII or destructors.
** No type-parametric user code.
* There are a number of other fine coroutine / actor languages in development presently. It's an area of focus across the PL community.

h3. I like the language but it really needs _$somefeature_.

At this point we are focusing on removing and stabilizing features rather than adding them. File a bug if you think it's important in terms of meeting the existing goals or making the language passably usable. Reductions are more interesting than additions though.
