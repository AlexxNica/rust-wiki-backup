h3. I'm impatient. Can you give a brief summary of the salient features?

h4. Safety oriented:
* Memory safe. No null pointers, wild pointers, etc. Automatic storage management.
* Mutability control. Immutable by default. No shared mutable state across tasks.
* Dynamic execution safety: task failure / unwinding, trapping, logging. RAII / dtors.
* Typestate system: ability to define complex invariants that hold over data structures.

h4. Concurrency and efficiency oriented:
* Explicit memory control. Layout and allocation control. Interior / value types.
* Very lightweight tasks (coroutines). Cheap to spawn thousands-to-millions.
* Stack iterators (effectively lambda-blocks w/o heap allocation).
* Static, native compilation. Emits ELF / PE / Mach-o files.
* Direct and simple interface to C code (switch stacks and call, ~8 insns).

h4. Practicality oriented:
* Multi-paradigm. pure-functional, concurrent-actor, imperative-procedural, OO.
** First class functions with bindings.
** Structurally-typed objects (no nominal types or type hierarchy).
* Multi-platform. Developed on Windows, Linux, OSX.
* UTF-8 strings, assortment of machine-level types.
* Works with existing native toolchains. GDB / Valgrind / Shark / etc.
* Practical rule-breaking: can break safety rules, if explicit about where and how. 

h3. Is it OO? How do I do this thing I normally do in an OO language?

It is multi-paradigm. Not everything is shoe-horned into the object abstraction. Many things you can do in OO languages you can do in Rust, but not everything, and not always using objects.

h3. How do you get away with "no null pointers"?

Data values in the language can only be constructed through a fixed set of initializer forms. Each of those forms requires that its inputs already be initialized. A dataflow analysis (the typestate system used elsewhere) ensures that local variables are initialized before use.

h3. What is the relationship between a module and a crate?

* A crate is a top-level compilation unit that corresponds to a single loadable object.
* A module is a (possibly nested) unit of name-management inside a crate.
* A crate contains an implicit, un-named top-level module.
* Recursive definitions can span modules, but not crates.
* Crates do not have global names, only a set of non-unique metadata tags.
* There is no global inter-crate namespace; all name management occurs within a crate.
** Using another crate binds the root of _its_ namespace into the user's namespace.

h3. Why is failure unwinding non-recoverable within a task? Why not try to "catch exceptions"?

In short, because too few guarantees could be statically made about the dynamic environment of the catch block to be able to safely resume.

In more detail: the origin-state of a failure is unknown by definition, therefore catching it would result in dropping the static typestate of the "catch block" to the lowest initialization typestate in the containing block, as well as dropping all user-defined conditions at any statements in the task. While it might be possible to produce a construct that worked this way, the set of operations that would be legal to perform in such a catch block would be minimal at a local level, and intractable at a task level: there would be no way to tell how much of the typestate assumed by the caller of the catch -- or any other functions in the task -- still holds. This sort of "resume in an arbitrarily damaged state" construct would defeat most of the other static rules in the language.

Rust provides, instead, three predictable and well-defined options for handling any combination of the three main categories of "catch" logic:
* Failure _logging_ is done by the integrated <code>note</code> statement.
* _Recovery_ after a failure is done by by trapping a task failure from _outside_ the task, where the typestate of other tasks is known to be unaffected.
* _Cleanup_ of resources is done by RAII-style objects with destructors.
Cleanup through RAII-style destructors  is more likely to work than in catch blocks anyways, since it will be better tested (part of the non-error control paths, so executed all the time).

h3. Does it run on Windows?

Yes. All development happens in lock-step on all 3 target platforms. Using mingw, not
cygwin.

h3. Are there any big programs written in it yet? I want to read big samples.

Sorry, no. It doesn't even have much of a standard library yet.

h3. Have you seen this Google language, Go? How does Rust compare?

Yes.
* Rust development was several years underway before Go launched, no direct inspiration.
** Though Pike's previous languages in the Go family (Newsqueak, Alef, Limbo) were influential.
* Go adopted semantics (safety and memory model) that are quite unsatisfactory.
** Shared mutable state.
** Global GC.
** Null pointers.
** No RAII or destructors.
** No type-parametric user code.
* There are a number of other fine coroutine / actor languages in development presently. It's an area of focus across the PL community.

h3. I like the language but it really needs _$somefeature_.

At this point we are focusing on removing and stabilizing features rather than adding them. File a bug if you think it's important in terms of meeting the existing goals or making the language passably usable. Reductions are more interesting than additions though.
