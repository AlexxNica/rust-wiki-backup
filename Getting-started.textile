h3. Prerequisites

Version numbers listed here are "what we're using"; the code may well work with earlier versions of these tools, we do not know minimum version requirements.

* A recent linux, OSX or win32 system.
* Python 3.1 ("download link":http://www.python.org/download/)
* Ocaml 3.11 ("download link":http://caml.inria.fr/download.en.html)
* GNU make 3.81
* git 1.7
* g++ 4.4 at least on linux, 4.5 on win32, and the 4.x gcc in Apple's SDK for OSX.
* Valgrind 3.5 (recommended but not required for linux)
* Texinfo's makeinfo and/or texi2pdf commands, if you wish to build HTML or PDF docs, respectively
* LLVM SVN revision 127624 or newer (**not** any stable release older than March 11, 2011), built for x86 (not x64 if you have one!).

h4. Debian-based Linux distributions

@sudo apt-get install ocaml ocaml-native-compilers@

64-bit systems: @sudo apt-get install g++-multilib ia32-libs@.

h4. Windows

We recommend developing under the newest "MinGW packages":http://www.mingw.org using their auto-installer.

The Ocaml build for MinGW is the one you want.

Also, to get your builds made in ocaml "native" mode (rather than bytecode) install the "flexdll package":http://alain.frisch.fr/flexdll.html and make sure its install dir (containing @flexlink.exe@) is in your @PATH@. Furthermore set this env var: @export FLEXLINKFLAGS="-nocygpath -L c:\path-to-mingw\lib"@ such that @flexlink.exe@ can find your MinGW libraries. You probably want to do this since bytecode mode is miserably slow for building @rustc.exe@.

h4. Mac

On the Mac (Darwin), you need to apply "a small patch to LLVM":https://gist.github.com/916582 in order to use the standard library under @rustc@.

h3. Installing LLVM

You'll need LLVM if you want anything other than the x86 backend of the bootstrap compiler. Because Rust doesn't support x64 yet you may need to configure LLVM using some special flags. On the Mac, use:

```sh
$ CXX='g++ -m32' CC='gcc -m32' CFLAGS=-m32 CXXFLAGS=-m32 LDFLAGS=-m32 ./configure --disable-bindings --{build,host,target}=i686-apple-darwin --enable-targets=x86,x86_64,cbe
$ make
$ make install
```

On 64-bit Linux, use:
```sh
$ CXX='g++ -m32' CC='gcc -m32' CFLAGS=-m32 CXXFLAGS=-m32 LDFLAGS=-m32 ./configure --disable-bindings --{build,host,target}=i686-unknown-linux-gnu --enable-targets=x86,x86_64,cbe
$ make
$ make install
```

On 32-bit Linux @./configure; make; make install@ should be sufficient.

h3. Downloading and building

<pre>
<code>
$ git clone git://github.com/graydon/rust.git
$ cd rust
$ mkdir build
$ cd build
$ ../configure
$ make check
</code>
</pre>
This will build and test the bootstrap compiler and standard library.

*Note:* On Linux or OS X, if you have valgrind installed, the tests will run slowly because they are running under valgrind. If you define @CFG_DISABLE_VALGRIND=1@ in your build environment or run configure with the @--disable-valgrind@ flag, you can see the tests running at "full" speed (though, of course, the bootstrap compiler generates terrible code).

h4. Notes specific to Mac OS X 10.5

Getting rust to build on OS X 10.5 requires some tweaking:
* Assuming you're using a gcc that came with Xcode 3.1, make sure it is gcc 4.2 rather than 4.0.1.  Xcode should come with both, although 4.0.1 is the default.  (See, for instance, "how to set gcc 4.2 as the default compiler on OS X Leopard":http://stackoverflow.com/questions/1165361/setting-gcc-4-2-as-the-default-compiler-on-mac-os-x-leopard).
* In addition to the @LD_LIBRARY_PATH@ environment variable, which should be set to something like @$HOME/rust/src:/usr/local/lib@, you'll need to export the @DYLD_LIBRARY_PATH@ environment variable with the same value as @LD_LIBRARY_PATH@.  Use something like @export DYLD_LIBRARY_PATH=$LD_LIBRARY_PATH@.
* Remove (or comment out) the @DSYMUTIL := dsymutil@ line of @rust/src/Makefile@.  

h3. Navigating

There's a quick guide to the source of the bootstrap compiler in src/boot/README and one for the self-hosted compiler in src/comp/README. You should probably look through whichever one corresponds to the compiler you're working on, if you're going to be contributing.

h3. Dealing with the issue tracker

The github issue tracker is somewhat weak. However, it exposes itself through an API and there's a "secondary front-end that is quite a bit more responsive":http://githubissues.heroku.com/#graydon/rust and a "tertiary front-end that is pleasantly minimal":http://izs.no.de/graydon/rust

h3. Picking something interesting to do

We're presently in the process of bootstrapping. This means we're using the first compiler (rustboot, written in ocaml) to develop a second compiler (rustc, written in rust). The state of the second compiler is incomplete, but it's advancing rapidly and needs lots of details filled in. When we complete rustc we will retire rustboot altogether. Therefore bugs or missing features in rustboot are only worth fixing at this point if they block completion of rustc; all other work should be feature-completion work on rustc.

The easiest way to figure out some rustc feature to work on is to try running 'make stage1/rustc'. This is the bootstrapping command for rustc to attempt to compile itself. It will fail, as rustc is currently incomplete. Whatever the next thing it's failing on, that's a fine thing to attempt to fix!

If that appears too involved, another approach is to look at the testsuite directory: test/run-pass. See if there is a test in there that rustboot can pass but rustc cannot; any test where there is a '.boot' executable produced during 'make check' but not a '.stage0' executable. Those are all missing features, that require someone to finish them.

h3. Communicating

Join irc.mozilla.org #rust if you want to discuss anything more "interactively", we try to remain on that channel during working hours in UTC-7 (US Pacific).

Join the "mailing list":https://mail.mozilla.org/listinfo/rust-dev if you want to have longer conversations.

In both cases, please follow the conduct guidelines on the [[Development policy]] page.