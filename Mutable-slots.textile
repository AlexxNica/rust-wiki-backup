h2. First-class, mutable, interior slots

The runtime representation of a @slot.<T>@ is bit-for-bit identical to the runtime representation of a @T@. This means that a parametric container can be given mutable and immutable variants by instantiating with an immutable element type @T@ and a mutable element type @slot.<T>@.

Providing first-class support for mutable, interior slots makes it possible to create mutable vectors without having to have two different kinds of vectors. This allows us to write a simple, polymorphic @map@:

bc. fn map.<T,U>(f : &fn(T) -> U, v : T[]) : U[] {
    ...
}

There is one single implementation of @map@, and the immutable version will produce an immutable vector, and the mutable version will produce a mutable version.

h3. Similarity to one-element tuples



h3. Collapsing nested slots

h3. Type checking

h4. Lvalue type checking

h4. Rvalue type checking

h3. Code generation

The code generated by ...

h3. Convenience forms

It might be nice to have a convenience constructor for mutable vectors, such as Ocaml's syntax:

bc. [| 1, 2, 3 |]

This would be equivalent to:

bc. [ slot 1, slot 2, slot 3 ]

It might also be nice to be able to express mutable vector types with a similar syntax, such as:

bc. int[||]

h3. Alternatives considered

We considered having mutability be an attribute of vectors, and possibly an attribute that could be used for custom collection types as well. But then this required some kind of subtyping relationship, where you would write @map@ as a function that accepted a vector with some sort of @mutable?@ attribute. In other words, there was some sort of notion of "mutability polymorphism." This made for much more complicated type signatures for @map@, and was ad hoc and didn't seem to correspond to familiar concepts from known type systems.
