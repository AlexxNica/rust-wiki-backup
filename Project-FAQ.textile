h3. What is this project's goal, in one sentence?

To design and implement a safe, concurrent, practical, static systems language.

h3. Why are you doing this?

Existing languages at this level of abstraction and efficiency are unsatisfactory. In particular:
* Too little attention paid to safety.
* Poor concurrency support.
* Lack of practical affordances, too dogmatic about paradigm.

h3. What are some non-goals?

* To employ any particularly cutting-edge technologies. Old, established techniques are better.
* To prize expressiveness, minimalism or elegance above other goals. These are desirable but subordinate goals. 
* To cover the "systems language" part all the way down to "writing an OS kernel".
* To cover the complete feature-set of C++, or any other language. It should provide majority-case features.
* To be 100% static, 100% safe, 100% reflective, or too dogmatic in any other sense. Trade-offs exist.
* To run on "every possible platform". It must eventually work without unnecessary compromises on widely-used hardware and software platforms.

h3. Is any part of this thing production-ready?

No. Feel free to play around, but don't expect completeness or stability yet. Expect incompleteness and breakage.

What exists presently is:
* A bootstrap compiler written in Ocaml.
** With lots of bugs and missing features.
** A very minimal built-in x86-emitting backend that produces inefficient code and object files for Linux, OSX and Win32.
* An incomplete but functional version of the runtime library.
* Some tests and documentation.
* The humble beginnings of a standard library. Mostly stubs.
* A self-hosted (written in Rust) compiler, which _only_ uses LLVM as a backend.
** Compiles a few smaller tests but is maturing rapidly.
** Produces _much_ smaller and faster code than the bootstrap compiler.
** Will eventually take over from the bootstrap compiler for further language development.

h3. Is this a completely Mozilla-planned and orchestrated thing?

No. It started as a part-time side project in 2006 and remained so for over 3 years. Mozilla got involved in 2009 once the language was mature enough to run some basic tests and demonstrate the idea.

h3. Why did you do so much work in private?

* A certain amount of shyness. Language work is somewhat political and flame-inducing.
* Languages designed by committee have a poor track record. Design coherence is important. There were a lot of details to work out and the initial developer (Graydon) had this full time job thing eating up most days.

h3. Why publish it now?

* The design is stable enough. All the major pieces have reached non-imaginary, initial implementation status. It seems to hold together ok.
* Languages solely implemented and supported by one person _also_ have a poor track record. To survive it'll need help.

h3. Are you going to use this to suddenly rewrite the browser and change everything? Is the Mozilla Corporation trying to force the community to use a new language?

No. The Mozilla Corporation's involvement is at the _labs_ level: the group concerned with doing _experiments_. The point is to explore some possibilities. No particular plan of use exists at the moment; any possible future uptake or use will depend (as always) on community interest.

h3. What's with the development policy? Why don't you take random pull requests?

Most of the development work on Rust is being done by Mozilla Corporation employees and so much of the copyright is owned by the Mozilla Foundation. Any time you have a legal entity involved in program development it's good to have a liability paper trail about where things came from, even if they're well licensed; helps for avoiding any possible rights/ownership disputes down the line. It's not at all unusual for development sponsored by larger institutions or organizations. See for example the FSF, ASF, Eclipse Foundation, or similar contributor agreements. This is just how it works.

h3. Why Github rather than the normal Mozilla setup (Mercurial / Bugzilla / Tinderbox)?

* This is a fresh codebase and has no existing ties to Mozilla infrastructure; there is no particular advantage to (re)using any of the above infrastructure, it would all have to be upgraded and adapted to our needs.
* Git has been progressing rapidly in the years since Mozilla picked Mercurial for its main development needs, and appears to be both more widely known and more accessible at this point.
* This reduces the administrative requirements for contributing to merely establishing a paper trail via a contributor agreement. There is no need for vouching, granting commit access to Mozilla facilities, or setting up Mozilla user accounts.

h3. Why a BSD-style license rather than MPL or tri-license?

* Partly due to preference of the original developer (Graydon).
* Partly due to the fact that languages tend to have a wider audience and more diverse set of possible embeddings and end-uses than focused, coherent products such as web browsers. We'd like to appeal to as many of those potential contributors as possible.