This is a compendium of ```match check``` expressions in libraries and rustc. My goal is to figure out how many there are of each kinds. I'm guessing there will be the following kinds of ```match check```s:

1. User input (we can't really do anything about this except add an error case. Time format strings are an example; anything involving parsing, basically.)
  * std::time::strftime
  * test cases in core::comm, core::run, core::str, std::ebml, std::getopts
  * serialization::deserialize_option
  * code generated by autoserialize
  * ```read_vtable_origin``` in ```astencode```
  * various things in ```tydecode```
1. Subsets of enums (hopefully will be addressed in the future with case classes / refinement types)
  * trans::base::trans_lval (type of a unary operation -- would be great if typeck could produce something with a refined type...)
  * std::list::head (great argument for refinements)
  * ```encoder::purity_static_method_family``` (we currently can't encode that static methods can never have purity ```extern_fn```)
1. Difficult stuff (example: ```match len % 3 { ...``` where you know where will only be three cases. We will probably never have a fancy enough type system to make this exhaustive)
  * std::base64 impl of to_base64 for ~[u8]
1. Easily rewritten (for example, when you only handle a specific variant and you can just pass its components instead)
  * trans::base::make_mono_id (a vec of mono_ids all constructed with mono_precise gets consumed immediately)
  * trans::base::llvm_type_name (only called on obvious enum and class types, so just pass the def_id and substs)
  * core::bool::from_str (already had a _ case!)
  * code dealing with expr_log things (made log_level an enum instead of an int)
  * matching on optimization levels in ```back::link``` and ```driver::driver``` (make optimization level an enum)
  * Log levels in ```expr_log``` (make it an enum rather than a uint)
  * ```syntax::attrs::find_linkage_metas``` (addressed by inlining ```find_linkage_attrs```, which didn't really need to be a separate function, into ```find_linkage_metas```)
1. Addressed by non-trivial refactoring (see send_map for an example)
  * core::send_map (several)
  * matches on ```ast::expr_loop_body``` and ```ast::expr_do_body``` things (refactoring the AST to eliminate junk -- this could have been also addressed with subsets-of-enums)
  * ```lint::check_fn``` -- there's currently no constraint that a function must have a function type (in the type context)
  * only some combinations of types are supported in a cast in ```middle::trans::consts```
  * ```encoder::encode_info_for_items```: item might map to a non-item node in the AST map
1. Results of metadata lookup (not much we can do here except add an error case, as in 1.)
  * trans::base::monomorphic_fn::maybe_instantiate_inline
  * ```decoder::item_to_def_like``` (the ```Variant``` case; ```item_parent_item``` returns an option)
  * ```get_trait_methods``` (doc for method might have an item_family that's not a purity value)
  * ```decoder::family_to_visibility``` (similar)