This is a compendium of ```match check``` expressions in libraries and rustc. My goal is to figure out how many there are of each kinds. I'm guessing there will be the following kinds of ```match check```s:

1. User input (we can't really do anything about this except add an error case. Time format strings are an example; anything involving parsing, basically.)
* std::time::strftime
* test cases in core::comm, core::run, core::str, std::ebml, std::getopts
* serialization::deserialize_option
* code generated by autoserialize
1. Subsets of enums (hopefully will be addressed in the future with case classes / refinement types)
* trans::base::trans_lval (type of a unary operation -- would be great if typeck could produce something with a refined type...)
* std::list::head (great argument for refinements)
1. Difficult stuff (example: ```match len % 3 { ...``` where you know where will only be three cases. We will probably never have a fancy enough type system to make this exhaustive)
* std::base64 impl of to_base64 for ~[u8]
1. Easily rewritten (for example, when you only handle a specific variant and you can just pass its components instead)
* trans::base::make_mono_id (a vec of mono_ids all constructed with mono_precise gets consumed immediately)
* trans::base::llvm_type_name (only called on obvious enum and class types, so just pass the def_id and substs)
* core::bool::from_str (already had a _ case!)
* code dealing with expr_log things (made log_level an enum instead of an int)
1. Addressed by non-trivial refactoring (see send_map for an example)
* core::send_map (several)
* matches on ```ast::expr_loop_body``` and ```ast::expr_do_body``` things (refactoring the AST to eliminate junk -- this could have been also addressed with subsets-of-enums)
1. Results of metadata lookup (not much we can do here except add an error case, as in 1.)
* trans::base::monomorphic_fn::maybe_instantiate_inline
1. Not sure, because there's no documentation of why it's safe to omit cases
* syntax::attr::find_linkage_metas